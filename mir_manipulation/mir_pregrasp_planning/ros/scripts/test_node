#! /usr/bin/env python

from __future__ import print_function

import tf
import numpy as np
import math
import rospy

from brics_actuator.msg import JointPositions
from geometry_msgs.msg import PoseStamped, PoseArray, Pose, Quaternion
from mcr_pose_generation_ros.pose_generator import PoseGenerator
from mcr_manipulation_pose_selector_ros.reachability_pose_selector import PoseSelector

class TestNode(object):

    def __init__(self):
        min_azimuth = 0.0
        max_azimuth = 0.0
        min_zenith = 0.0
        max_zenith = 0.0
        min_roll = 0.0
        max_roll = 0.0
        # min_roll = 0.0
        # max_roll = 0.0
        linear_step = 0.01
        angular_step = 0.5
        min_distance_to_object = 0.0
        max_distance_to_object = 0.0
        max_samples = 10
        min_height = 0.0
        max_height = 0.0

        gripper_matrix= [[-1.0, 0.0, 0.0, 0.0],
                        [ 0.0, 1.0, 0.0, 0.0],
                        [ 0.0, 0.0, -1.0, 0.11],
                        [ 0.0, 0.0, 0.0, 1.0]]
        self._ee_to_arm_transform= np.array([[1.0, 0.0, 0.0, 0.0],
                                            [ 0.0, 1.0, 0.0, 0.0],
                                            [ 0.0, 0.0, 1.0, -0.11],
                                            [ 0.0, 0.0, 0.0, 1.0]])
        self.pose_generator = PoseGenerator()
        self.pose_generator.set_min_azimuth(math.radians(min_azimuth))
        self.pose_generator.set_max_azimuth(math.radians(max_azimuth))
        self.pose_generator.set_min_zenith(math.radians(min_zenith))
        self.pose_generator.set_max_zenith(math.radians(max_zenith))
        self.pose_generator.set_min_roll(math.radians(min_roll))
        self.pose_generator.set_max_roll(math.radians(max_roll))
        self.pose_generator.set_linear_step(linear_step)
        self.pose_generator.set_angular_step(math.radians(angular_step))
        self.pose_generator.set_min_distance_to_object(min_distance_to_object)
        self.pose_generator.set_max_distance_to_object(max_distance_to_object)
        self.pose_generator.set_max_samples(max_samples)
        self.pose_generator.set_min_height(min_height)
        self.pose_generator.set_max_height(max_height)
        self.pose_generator.set_gripper_config_matrix(gripper_matrix)

        self.reachability_pose_selector = PoseSelector()

        self.pose_array_pub = rospy.Publisher('~pose_samples', PoseArray, queue_size=1)
        self.pose_pub = rospy.Publisher('~pose_in', PoseStamped, queue_size=1)
        self.joint_msg_pub = rospy.Publisher('/arm_moveit_client/target_configuration', JointPositions, queue_size=1)
        self.pose_out_pub = rospy.Publisher('~pose_out', PoseStamped, queue_size=1)
        rospy.sleep(0.5)

    def test(self):
        input_pose = PoseStamped()
        input_pose.pose.position.x = 0.5
        input_pose.pose.position.y = 0.1
        input_pose.pose.position.z = 0.1
        input_pose.pose.orientation.w = 1.0
        input_pose.header.stamp = rospy.Time.now()
        input_pose.header.frame_id = 'base_link'
        self.pose_pub.publish(input_pose)
        rospy.sleep(1.0)
        # first try top down
        pose_samples = self._generate_samples(input_pose, pitch_offset=180.0)
        self.pose_array_pub.publish(pose_samples)
        reachable_pose, joint_msg, _ = self.reachability_pose_selector.get_reachable_pose_and_configuration(pose_samples, None)
        if reachable_pose is not None:
            rospy.loginfo('Found solution top down')
            self.pose_out_pub.publish(reachable_pose)
            self.joint_msg_pub.publish(joint_msg)
            return
        pitch_ranges = [(-30.0, 0.0), (-60.0, -30.0), (-90.0, -60.0), (0.0, 10.0)]
        if input_pose.pose.position.y > 0.0:
            yaw_ranges = [(0.0, 30.0), (30.0, 60.0), (60.0, 90.0)]
        else:
            yaw_ranges = [(-30.0, 0.0), (-60.0, -30.0), (-90.0, -60.0)]
        found_solution = False
        for pitch_range in pitch_ranges:
            for yaw_range in yaw_ranges:
                # pose generator
                # self.pose_generator.set_min_zenith(math.radians(pitch_range[0]))
                # self.pose_generator.set_max_zenith(math.radians(pitch_range[1]))
                # self.pose_generator.set_min_roll(math.radians(yaw_range[0]))
                # self.pose_generator.set_max_roll(math.radians(yaw_range[1]))
                # pose_samples = self.pose_generator.calculate_poses_list(input_pose, number_of_fields=2)

                # custom function
                pose_samples = self._generate_samples(
                        input_pose,
                        roll_min=0.0, roll_max=0.0, roll_offset=0.0, roll_samples=1,
                        pitch_min=pitch_range[0], pitch_max=pitch_range[1], pitch_offset=180.0, pitch_samples=5,
                        yaw_min=yaw_range[0], yaw_max=yaw_range[1], yaw_offset=0.0, yaw_samples=5)

                if input_pose.pose.position.y > 0.0:
                    pose_samples.poses = pose_samples.poses[::-1]

                self.pose_array_pub.publish(pose_samples)
                reachable_pose, joint_msg, _ = self.reachability_pose_selector.get_reachable_pose_and_configuration(pose_samples, None)
                if reachable_pose is not None:
                    print(pitch_range)
                    print(yaw_range)
                    found_solution = True
                    rospy.loginfo('Found solution')
                    self.pose_out_pub.publish(reachable_pose)
                    self.joint_msg_pub.publish(joint_msg)
                    # rospy.sleep(1.0)
                    break
            if found_solution:
                break
        if not found_solution:
            rospy.logwarn('No solution found')

    def _generate_samples(self, input_pose,
                          roll_min=0.0, roll_max=0.0, roll_samples=1, roll_offset=0.0,
                          pitch_min=0.0, pitch_max=0.0, pitch_samples=1, pitch_offset=0.0,
                          yaw_min=0.0, yaw_max=0.0, yaw_samples=1, yaw_offset=0.0):
        roll_samples = list(np.linspace(roll_min, roll_max, roll_samples))
        pitch_samples = list(np.linspace(pitch_min, pitch_max, pitch_samples))
        yaw_samples = list(np.linspace(yaw_min, yaw_max, yaw_samples))

        pose_samples = PoseArray()
        pose_samples.header = input_pose.header
        for roll in roll_samples:
            for pitch in pitch_samples:
                for yaw in yaw_samples:
                    pose = Pose()
                    pose.position = input_pose.pose.position
                    roll_rad = math.radians(roll + roll_offset)
                    pitch_rad = math.radians(pitch + pitch_offset)
                    yaw_rad = math.radians(yaw + yaw_offset)
                    pose.orientation = Quaternion(*tf.transformations.quaternion_from_euler(roll_rad, pitch_rad, yaw_rad))
                    transformed_pose = self._get_arm_pose_from_ee_pose(pose)
                    pose_samples.poses.append(transformed_pose)
        return pose_samples

    def _get_arm_pose_from_ee_pose(self, gripper_pose):
        """ Transform 'gripper_pose' into 'arm_pose' such that if 'gripper_pose' represents where
        the gripper must be, then 'arm_pose' represents where the arm_link_5 must be

        :gripper_pose: geometry_msgs/Pose
        :returns: geometry_msgs/Pose

        """
        # convert gripper_pose to gripper_pose_matrix
        gripper_pose_matrix = tf.transformations.quaternion_matrix([
            gripper_pose.orientation.x,
            gripper_pose.orientation.y,
            gripper_pose.orientation.z,
            gripper_pose.orientation.w])
        gripper_pose_matrix[0, 3] = gripper_pose.position.x
        gripper_pose_matrix[1, 3] = gripper_pose.position.y
        gripper_pose_matrix[2, 3] = gripper_pose.position.z

        # transform gripper to arm_pose using a transformation matrix
        arm_pose_matrix = np.dot(gripper_pose_matrix, self._ee_to_arm_transform)

        # convert arm_pose_matrix to arm_pose
        arm_pose = Pose()
        arm_pose.position.x = arm_pose_matrix[0, 3]
        arm_pose.position.y = arm_pose_matrix[1, 3]
        arm_pose.position.z = arm_pose_matrix[2, 3]
        quaternion = tf.transformations.quaternion_from_matrix(arm_pose_matrix)
        arm_pose.orientation = Quaternion(*quaternion)
        return arm_pose

if __name__ == '__main__':
    rospy.init_node('test_node')
    TN = TestNode()
    TN.test()
    rospy.spin()
